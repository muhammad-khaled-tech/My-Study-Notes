---
title: Merge Sort
created: 2026-01-07
tags:
  - algorithms
  - sorting
  - divide-and-conquer
  - O(nlogn)
  - stable
related:
  - "[[_Algorithms MOC]]"
  - "[[Quick Sort]]"
  - "[[Algorithm Paradigms]]"
complexity:
  best: O(n log n)
  average: O(n log n)
  worst: O(n log n)
  space: O(n)
---

أهلاً بك يا بطل في "التقيل"! إحنا دلوقتي قدام واحد من أعظم الابتكارات في تاريخ الـ Computer Science. لو الـ Bubble والـ Selection والـ Insertion Sort هما "العجلة"، فالـ **Merge Sort** هو "المحرك النفاث".

ده أول خوارزمية هندرسها بتكسر حاجز الـ $O(N^2)$ وبتاخدنا لعالم الـ $O(N \log N)$. اللي صمم الخوارزمية دي هو العالم الأسطوري **John von Neumann** سنة 1945، ومن ساعتها وهي حجر أساس في أنظمة كتير.

---

## [خوارزمية الترتيب بالدمج - Merge Sort]

### التعريف السريع

الـ **Merge Sort** هي خوارزمية ترتيب بتتبع منهجية **فرق تسد (Divide and Conquer)**. فكرتها الأساسية هي تقسيم المصفوفة الكبيرة لأجزاء صغيرة جداً لحد ما نوصل لعناصر مفردة، وبعدين نعيد دمجهم (Merging) بترتيب صح. هي خوارزمية **Stable** جداً وبتحافظ على أدائها السريع مهما كانت حالة الداتا.

### الشرح التفصيلي

بص يا هندسة، عشان تفهم الـ Merge Sort لازم تنسى فكرة إننا بنرتب المصفوفة وهي حتة واحدة. الخوارزمية دي بتتعامل بمبدأ "المشاكل الكبيرة حلها في تفتيتها لمشاكل أصغر".

#### 1. المستوى السطحي (إيه ده؟)

تخيل إن عندك 1000 ورقة ملخبطة وعايز ترتبهم. بدل ما تقعد تدور فيهم كلهم، هتقسمهم نصين (500 و 500)، وكل نص تقسمه نصين (250 و 250)، وهكذا لحد ما يبقى معاك ورقة واحدة في إيدك. الورقة الواحدة دي "مترتبة" منطقياً. تبدأ بقى تلم الورق ده تاني، كل ورقتين مع بعض بالترتيب، وبعدين كل مجموعتين مع بعض بالترتيب، لحد ما ترجع للـ 1000 ورقة وهي مترتبة بالكامل.

#### 2. المستوى المتوسط (إزاي بيشتغل؟)

العملية بتتم على تلات مراحل أساسية (Divide, Conquer, Combine):

- **Divide (التقسيم):** بنحسب الـ Mid بتاع المصفوفة ونقسمها لـ Left Sub-array و Right Sub-array. العملية دي بتفضل تتكرر باستخدام الـ **Recursion** لحد ما نوصل لمرحلة إن كل Sub-array فيها عنصر واحد بس (Base Case).
    
- **Conquer (الحل):** بما إن المصفوفة اللي فيها عنصر واحد هي مترتبة أصلاً، فإحنا كده "حلينا" أصغر مشكلة.
    
- **Combine (الدمج):** دي "الزتونة" وكل الشغل هنا. بنستخدم دالة اسمها `merge` وظيفتها إنها تاخد مصفوفتين مترتبين وتدمجهم في مصفوفة واحدة كبيرة مترتبة. العملية دي بتطلع لفوق في الـ Recursion Tree لحد ما المصفوفة الأصلية كلها تترتب.
    

#### 3. المستوى العميق (ليه اتصمم كده؟ والـ Trade-offs)

ليه الـ Merge Sort تعتبر ثورة؟

- **الـ Time Complexity:** في كل أنواع الـ Sorting اللي فاتت، لو الـ $N$ زادت للضعف، الوقت بيزيد 4 أضعاف ($N^2$). لكن في الـ Merge Sort، الوقت بيمشي بمعدل $N \log N$. ده معناه إن لو عندك مليون عنصر، الـ Merge Sort هتخلصهم في لمح البصر مقارنة بالـ Bubble Sort اللي ممكن تقعد سنين.
    
- **الـ Worst Case:** الميزة المرعبة هنا إن الـ Merge Sort دايما $O(N \log N)$. حتى لو الداتا معكوسة أو ملخبطة تماماً، هي مش بتتأثر، عكس الـ Quick Sort اللي ممكن يقع لـ $O(N^2)$ في حالات معينة.
    
- **الـ Memory Trade-off (العيب الوحيد):** الـ Merge Sort مش **In-place**. يعني عشان تدمج مصفوفتين، لازم تحجز مكان إضافي (Temporary Array) في الـ RAM بنفس حجم المصفوفة الأصلية. فلو عندك مصفوفة 1GB، هتحتاج 1GB تانية زيادة عشان الترتيب. ده بنسميه **Space Complexity of $O(N)$**.
    
- **الـ Stability:** هي خوارزمية Stable جداً، وده بيخليها المفضلة لما بنرتب Objects معقدة (زي ترتيب ركاب طيارة حسب الدرجة وبعدين حسب الاسم).
    

#### كيفية العمل (How It Works)

الخوارزمية بتعتمد على الـ Recursion بشكل كلي، والخطوات كالتالي:

1. لو المصفوفة فيها عنصر واحد أو صفر، ارجع (دي الـ Base Case).
    
2. اقسم المصفوفة لنصين: `Left = [0...mid]` و `Right = [mid+1...end]`.
    
3. نادي الـ `mergeSort` على النص الشمال.
    
4. نادي الـ `mergeSort` على النص اليمين.
    
5. نادي دالة الـ `merge(left, right)` عشان تدمج النصين اللي اترتبوا دول في المصفوفة الأصلية.
    

عملية الـ Merge بتتم إزاي؟

بنحط مؤشر (Pointer) على أول الـ Left ومؤشر على أول الـ Right. بنقارن العنصرين، الصغير فيهم نحطه في المصفوفة الأصلية ونحرك المؤشر بتاعه خطوة. بنكرر ده لحد ما نخلص المصفوفتين.

#### الأمثلة العملية

ده كود C++ كامل لعملية الـ Merge Sort، ركز جداً في دالة الـ `merge` لأنها هي "المحرك" بتاع الخوارزمية.

C++

```
#include <iostream>
#include <vector>

using namespace std;

// دالة الـ Merge: هي المسؤولة عن دمج مصفوفتين مترتبين في مصفوفة واحدة
void merge(vector<int>& arr, int left, int mid, int right) {
    // بنحسب أحجام المصفوفتين المؤقتين
    int n1 = mid - left + 1;
    int n2 = right - mid;

    // بنعمل مصفوفات مؤقتة عشان نخزن فيها الداتا قبل الدمج
    // لاحظ إن ده هو الـ Space Penalty O(N)
    vector<int> L(n1), R(n2);

    // بننقل الداتا للمصفوفات المؤقتة
    for (int i = 0; i < n1; i++)
        L[i] = arr[left + i];
    for (int j = 0; j < n2; j++)
        R[j] = arr[mid + 1 + j];

    // بنبدأ عملية الدمج الحقيقية باستخدام 3 مؤشرات
    int i = 0; // مؤشر للمصفوفة الشمال
    int j = 0; // مؤشر للمصفوفة اليمين
    int k = left; // مؤشر للمصفوفة الأصلية اللي بنعدل فيها

    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) { // لو عنصر الشمال أصغر أو يساوي (عشان الـ Stability)
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    // لو فيه عناصر فضلت في المصفوفة الشمال (بسبب اختلاف الأحجام)
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    // لو فيه عناصر فضلت في المصفوفة اليمين
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

// دالة الـ MergeSort: الدالة الـ Recursive اللي بتقسم المصفوفة
void mergeSort(vector<int>& arr, int left, int right) {
    if (left >= right) {
        return; // Base Case: وصلنا لعنصر واحد
    }

    // بنحسب نقطة المنتصف (طريقة أمنة عشان نتجنب الـ Overflow)
    int mid = left + (right - left) / 2;

    // بنقسم المصفوفة لنصين وننادي عليهم ريكيرسيفلي
    mergeSort(arr, left, mid);      // ترتيب النص الشمال
    mergeSort(arr, right, mid + 1); // ترتيب النص اليمين (لاحظ هنا الترتيب الصحيح للبرامترات)
    // التعديل الصحيح للبارامترات:
    // mergeSort(arr, left, mid);
    // mergeSort(arr, mid + 1, right);

    // دمج النصين المترتبين
    merge(arr, left, mid, right);
}

// دالة لطباعة المصفوفة
void printArray(const vector<int>& arr) {
    for (int x : arr) cout << x << " ";
    cout << endl;
}

int main() {
    vector<int> arr = {38, 27, 43, 3, 9, 82, 10};
    int n = arr.size();

    cout << "Original Array: ";
    printArray(arr);

    // بننادي الـ Merge Sort من أول index لحد آخر index
    mergeSort(arr, 0, n - 1);

    cout << "Sorted Array: ";
    printArray(arr);

    return 0;
}

// الـ Output المتوقع: 3 9 10 27 38 43 82
```

---

#### الـ Edge Cases والتفاصيل الدقيقة

1. **Memory Constraints:** لو الـ Memory عندك محدودة جداً (زي في الـ Microcontrollers)، الـ Merge Sort ممكن متبقاش أحسن خيار بسبب الـ $O(N)$ space. هنا بنفكر في **Quick Sort**.
    
2. **External Sorting:** دي أهم حالة للـ Merge Sort. تخيل لو عندك فايل حجمه 100GB والـ RAM عندك 8GB بس. هترتبه إزاي؟ بنستخدم الـ **External Merge Sort**. بنقسم الفايل لحتت صغيرة (كل واحدة 8GB)، نرتبهم بالـ Merge Sort ونخزنهم على الديسك، وبعدين ندمجهم كلهم مع بعض. ده اللي بتعمله الـ Databases حرفياً.
    
3. **Linked Lists:** الـ Merge Sort هي "الملكة" في ترتيب الـ Linked Lists. ليه؟ لأننا مش محتاجين نأكسس العناصر بـ Index عشوائي، إحنا بس بنمشي بالتسلسل، وده بيتناسب جداً مع طبيعة الـ Linked List. وكمان الـ Space complexity في حالة الـ Linked List بيبقى $O(1)$ لو عملناها صح.
    

### الربط بالمفاهيم التانية

الموضوع ده مرتبط بـ:

- **Recursion & Stack Memory:** كل "تقسيمة" بتفتح Stack Frame جديد لحد ما نوصل للـ Base Case.
    
- **Divide and Conquer:** نفس المنهجية المستخدمة في الـ Binary Search والـ Fast Fourier Transform (FFT).
    
- **External Memory Algorithms:** الطريقة اللي الـ Operating System والـ Databases بيتعاملوا بيها مع الداتا العملاقة اللي مش بتكفي في الـ RAM.
    

### المصادر والقراءة الإضافية

- **كتاب Introduction to Algorithms (CLRS):** الفصل الرابع (Divide-and-Conquer) والفصل الثاني (Merge Sort).
    
- **Coursera - Algorithms Specialization (Stanford):** شرح Tim Roughgarden للـ Merge Sort هو الأفضل عالمياً.
    
- **John von Neumann's Biography:** عشان تعرف العبقرية وراء الخوارزمية دي في وقت مكنش فيه حواسب شخصية أصلاً.
    

---

**رأيك إيه يا بطل في الـ Merge Sort؟** تحس إنك بدأت تلمس الفرق بين الخوارزميات البدائية والخوارزميات اللي بجد؟ تحب نكمل الـ Sorting ونشوف الـ **Quick Sort** عشان نقارن بينهم، ولا حابب نغير المسار؟