

# ุงูุฌุฒุก ุงูุฃูู: ุงูููุณูุฉ ุงูุนูููุฉ (ููุงุฐุง ุงูู Hashingุ)

### 1. ูุนุถูุฉ ุงูุจุญุซ (The Search Dilemma)

ุชุฎูู ูู ุนูุฏู ูุฎุฒู ููู **ููููู** ูุฑุชููุฉุ ููู ูุฑุชููุฉ ูููุง "ุฑูู ุชุณูุณูู" (Serial Number) ูููู ูู 10 ุฃุฑูุงู.

- **ูู ุงุณุชุฎุฏูุช Array ุฃู Linked List:** ุนุดุงู ุชูุงูู ูุฑุชููุฉ ูุนููุฉุ ูุชุถุทุฑ ุชูุดู ุนูููู ูุงุญุฏุฉ ูุงุญุฏุฉ. ุฏู ุจูุงุฎุฏ ููุช $O(n)$.
    
- **ูู ุงุณุชุฎุฏูุช BST:** ูุชุงุฎุฏ ููุช $O(\log n)$. ูุนูู ูู ุนูุฏู ููููู ุนูุตุฑุ ูุชุนูู ุญูุงูู 20 ููุงุฑูุฉ.
    

**ุงูุณุคุงู ุงูุตุนุจ:** ูู ููุฏุฑ ููุงูู ุงููุฑุชููุฉ ูู **ุฎุทูุฉ ูุงุญุฏุฉ ุจุณ** ($O(1)$) ูููุง ูุงู ุนุฏุฏ ุงููุฑุงุชููุ ุงูุฅุฌุงุจุฉ ูู: **ูุนูุ ุจุงูุญุณุงุจ ูุง ุจุงูุชุฏููุฑ.**

### 2. ููุฑุฉ ุงูู "Direct Address Table" (ุงูุญู ุงูุจุฏุงุฆู)

ุงูุญู ุงูุฃุณูู ูู ุฅููุง ูุญุฌุฒ ูุตูููุฉ (Array) ุญุฌููุง ูุบุทู ูู ุงูุฃุฑูุงู ุงูุชุณูุณููุฉ ุงูููููุฉ. ูู ุงูุฃุฑูุงู ูู 0 ูู 99ุ ูุญุฌุฒ Array ูููุง 100 ุฎุงูุฉ. ุงููุฑุชููุฉ ุฑูู 50 ูุญุทูุง ูู ุงูู Index ุฑูู 50.

- **ุงููุดููุฉ:** ูู ุงูุฃุฑูุงู ุงูุชุณูุณููุฉ ููููุฉ ูู 10 ุฃุฑูุงู (ูููุงุฑ ุงุญุชูุงู)ุ ูุชุญุชุงุฌ Array ุญุฌููุง ูููุงุฑ! ุฏู "ุฅุณุฑุงู" ูุฑุนุจ ูู ุงูููููุฑู ูุฃูู ุบุงูุจุงู ูุนูุฏูุด ุบูุฑ 1000 ูุฑุชููุฉ ุจุณ.
    

```mermaid
graph LR
    subgraph "Direct Addressing"
    K1[Key: 5] --> I1[Index: 5]
    K2[Key: 99] --> I2[Index: 99]
    end
    
    Array["Array[100]"]
    I1 --> Array
    I2 --> Array
```
### 3. ุงูุญู ุงูุนุจูุฑู: ุงูู Hashing (ุนูููุฉ ุงูุชูููุด)

ุงูู Hashing ูู ุนูููุฉ "ุถุบุท" ุฃู "ุชูููุด" ูููุฌุงู ุงููุงุณุน (ูููุงุฑ ุฑูู) ููุฌุงู ุตุบูุฑ (ูุซูุงู 100 ุฎุงูุฉ) ุจุงุณุชุฎุฏุงู ูุนุงุฏูุฉ ุฑูุงุถูุฉ.

- **ุงูู Hash Function:** ูู "ุงูููุฑูุฉ". ุชุฏููุง ุฑูู ุถุฎู (Key)ุ ุชุทูุนููุง ุฑูู ุตุบูุฑ (Index) ููุน ุฌูู ุญุฏูุฏ ุงููุตูููุฉ ุจุชุงุนุชูุง.


```mermaid
graph LR
    subgraph "Hashing Magic"
    K1[Key: 1,234,567] --> HF{Hash Function}
    K2[Key: 9,876,543] --> HF
    HF --> I1[Index: 7]
    HF --> I2[Index: 3]
    end
    
    style HF fill:#f96,stroke:#333,stroke-width:2px
```

---

# ุงูุฌุฒุก ุงูุซุงูู: ุงูุฑูุงุถูุงุช ูุฑุงุก ุงูู Hash Function

ุงููุนุงุฏูุฉ ุงูุฃุดูุฑ ูุงูุฃุจุณุท ุงููู ุงุณุชุฎุฏููุง ุจุดูููุฏุณ ูููุง ูู **"ุจุงูู ุงููุณูุฉ" (Modulo Operator)**:

$$index = key \pmod{size}$$

### ููู ุจูุณุชุฎุฏู ุจุงูู ุงููุณูุฉุ

ูุฃู ูุงุชุฌ ุจุงูู ุงููุณูุฉ ุนูู ุฃู ุฑูู (ูุซูุงู 10) ูุณุชุญูู ูุทูุน ุฃูุจุฑ ูู 9 ุฃู ุฃุตุบุฑ ูู 0. ุฏู ุจูุถูู ุฅููุง ุฏุงููุงู "ุฌูู ุงูููุนุจ" (Array Bounds).

ูุซุงู ุนููู (ุนุตุฑ ุฏูุงุบ):

ูู ุนูุฏูุง ูุตูููุฉ ุญุฌููุง (Size) = 10.

1. ุงูุฑูู **15**:-------------------->  $15 \pmod{10} = 5$. (ุณููู ูู ุงูุฎุงูุฉ 5).
    
2. ุงูุฑูู **7**:--------------------> $7 \pmod{10} = 7$. (ุณููู ูู ุงูุฎุงูุฉ 7).
    
3. ุงูุฑูู **25**:--------------------> $25 \pmod{10} = 5$. (**ููุง ุจุฏุฃุช ุงููุดููุฉ!**).

### ๐ ุฃูุซูุฉ ุญุณุงุจูุฉ
    
```mermaid
graph TD
    subgraph "Hash Function Examples size=10"
    K1[Key: 15] --> C1["15 % 10 = 5"] --> I1[Index: 5]
    K2[Key: 7] --> C2["7 % 10 = 7"] --> I2[Index: 7]
    K3[Key: 25] --> C3["25 % 10 = 5"] --> I3[Index: 5 โ๏ธ Collision!]
    K4[Key: 103] --> C4["103 % 10 = 3"] --> I4[Index: 3]
    end
    
    style I3 fill:#f66,stroke:#333,stroke-width:3px
```
---

# ุงูุฌุฒุก ุงูุซุงูุซ: ูุงุฑุซุฉ ุงูู Collision (ุงูุชุตุงุฏู)

ุจูุง ุฅููุง "ุจูููุด" ุฃุฑูุงู ูุชูุฑ ูู ูุณุงุญุฉ ุตุบูุฑุฉุ ุทุจูุนู ุฌุฏุงู ุฅู ุฑูููู ูุฎุชูููู ูุฑูุญูุง ูููุณ ุงูููุงู. ุฏู ุจูุณููู **Collision**.

### ุฅุฒุงู ุจูุญู ุงูุฎูุงูุฉ ุฏูุ (Collision Resolution)

ููู ูุฏุฑุณุชูู ูุจุงุฑุ ูุจุดูููุฏุณ ูููุง ุงุฎุชุงุฑ ุงููุฏุฑุณุฉ ุงูุฃูุถู ูู ุงููุฑููุฉ ููู **Separate Chaining**:

- **ุงูููุฑุฉ:** ุจุฏู ูุง ุงูุฎุงูุฉ ูู ุงููุตูููุฉ ุชุดูู "ุฑูู"ุ ููุฎูููุง ุชุดูู "ุนููุงู" (Pointer). ุงูุนููุงู ุฏู ุจูุดุงูุฑ ุนูู Linked List.
    
- **ุงููู ุจูุญุตู:** ูู ุฑูู 5 ุฑุงุญ ููุฎุงูุฉ 5ุ ูุนูู ููุฏ ูุฃุญุทูุง ููุงู. ุทุจ ูู ุฑูู 15 ุฌู ูููุณ ุงูุฎุงูุฉุ ูุฑุจุทู "ูุฑุง" ุฑูู 5 ูู ููุณ ุงูุณูุณูุฉ.
    
## ูุงุฑุซุฉ ุงูู Collision ูุญููููุง

> [!danger] ุงูุชุตุงุฏู (Collision) ุนูุฏูุง ุชููุชุฌ ุฏุงูุฉ ุงูู Hash ููุณ ุงูู index ูููุชุงุญูู ูุฎุชูููู.

### ๐ฅ ุฃุณุจุงุจ ุงูุชุตุงุฏู

```mermaid
graph TD
    A[Universe of Keys] --> B{Hash Function}
    B --> C[Limited Array Size]
    
    K1[15] --> B
    K2[25] --> B
    K3[35] --> B
    
    B --> I[Index 5]
    
    style I fill:#f66,stroke:#333
```
---

# ุงูุฌุฒุก ุงูุฑุงุจุน: ููุฏ "ูุฑููุด" (ุชุฏุฑูุจ ุจุณูุท ูุจู ุงูุฌุฏ)

ุชุนุงู ูุทุจู ููุฑุฉ ุงูู Hash Function ุจุณ ุจุดูู ุจุณูุท ุฌุฏุงู ุจุนูุฏ ุนู ุงูุชุนููุฏุงุชุ ุนุดุงู ูุชุฃูุฏ ุฅู ุงูููููู ูุตู.



```C++
#include <iostream>

int main() {
    int tableSize = 10;
    int myData[] = {15, 22, 35, 42};

    for(int i = 0; i < 4; i++) {
        // ุญุณุงุจ ุงูู Index
        int index = myData[i] % tableSize; 
        
        std::cout << "Value: " << myData[i] 
                  << " goes to Index: " << index << std::endl;
    }
    return 0;
}
```

```output
Value: 15 goes to Index: 5
Value: 22 goes to Index: 2
Value: 35 goes to Index: 5
Value: 42 goes to Index: 2

```


---

# ุงูุฌุฒุก ุงูุฎุงูุณ: ุชุฎูู "ุงููุฃุณุงุฉ" ูู ุงูููููุฑู

ุชุฎูู ูู ุฅูุช ุนุงูู ูุตูููุฉ (Array) ุนุงุฏูุฉ ูู 5 ุฎุงูุงุชุ ูุฌูุช ุชุฎุฒู ุงูุฃุฑูุงู ุฏู:

- ูุชุญุท ุงูู 15 ูู ุงูุฎุงูุฉ 0.
    
- ููุง ุชูุฌู ุชุญุท ุงูู 35ุ ูุชูุงูู ุงูุฎุงูุฉ 0 ูุญุฌูุฒุฉ.. ูุชุนูู ุฅููุ ูู "ุฏูุณุช" ุงูู 15 ูุญุทูุช ุงูู 35 ููุงููุงุ ูุจูู ุถูุนุช ุจูุงูุงุชู (Data Loss).
    

---

# ุงูุฌุฒุก ุงูุณุงุฏุณ: ููุฏ "ูุฑููุด" (ุฅุฒุงู ุจูุญู ุงูุฎูุงูุฉ ุฏู ูุฏููุงูุ)

ูุจู ูุง ูุฏุฎู ูู "ุชููู" ููุฏ ุจุดูููุฏุณ ูููุงุ ุชุนุงู ูุดูู ุฃุจุณุท ุทุฑููุฉ ุจุฑูุฌูุฉ ูุญู ุงููุดููุฉ ุฏู ููู **ุงูู Chaining** (ุฅูู ุฃุญูู ูู ุฎุงูุฉ ูู Array ุชุงููุฉ ุตุบูุฑุฉ ุฃู Linked List).

ุชุนุงู ูุนูู ููุฏ "ูุฏูู" ุฌุฏุงู ุจูุณุชุฎุฏู `vector` ุฌูู `array` ุนุดุงู ููุถุญ ุงูููุฑุฉ ูู ุบูุฑ ุชุนููุฏ ุงูู Pointers:



```C++
#include <iostream>
#include <vector>

int main() {
    int size = 5;
    // ูุตูููุฉ ูู ุงูู Vectors (ูู ุฎุงูุฉ ุนุจุงุฑุฉ ุนู ุดูุทุฉ ุจุชุดูู ุฃุฑูุงู ูุชูุฑ)
    std::vector<int> hashTable[5]; 

    int keys[] = {15, 22, 35, 42};

    for(int i = 0; i < 4; i++) {
        int index = keys[i] % size;
        // ุจูุถูู ุงูุฑูู ูู ุงูุดูุทุฉ ุจุชุงุนุชู ุญุชู ูู ููู ุบูุฑู
        hashTable[index].push_back(keys[i]); 
    }

    // ุชุนุงู ูุชูุฑุฌ ุนูู ุดูู ุงูุฌุฏูู
    for(int i = 0; i < size; i++) {
        std::cout << "Index " << i << ": ";
        for(int val : hashTable[i]) {
            std::cout << val << " -> ";
        }
        std::cout << "NULL" << std::endl;
    }

    return 0;
}
```
```output
Index 0: 15 -> 35 -> NULL
Index 1: NULL
Index 2: 22 -> 42 -> NULL
Index 3: NULL
Index 4: NULL

```
### ุฅูู ุงููู ุญุตู ููุงุ

1. ูู ุงูุฎุงูุฉ (Index 0): ุงูู Vector ุดุงู ุงูู 15 ูุงูู 35 ูุน ุจุนุถ.
    
2. ูู ุงูุฎุงูุฉ (Index 2): ุงูู Vector ุดุงู ุงูู 22 ูุงูู 42 ูุน ุจุนุถ.
    
3. ุจุงูู ุงูุฎุงูุงุช ูุถูุช ูุงุถูุฉ.
    


---

# ุงูุฌุฒุก ุงูุณุงุจุน: ููู ุจุดูููุฏุณ ูููุง ูุณุชุฎุฏูุด ุงูู Vectorุ

ุจูุง ุฅููุง ูู ููุฑุณ Data Structuresุ ุงููุฏู ุฅููุง ูุจูู ูู ุญุงุฌุฉ ูู ุงูุตูุฑ (Low-level). ุงูู `std::vector` ุงููู ุงุณุชุฎุฏูุชู ุฃูุง ููู ูู ุฃุฏุงุฉ ุฌุงูุฒุฉ ูู C++ุ ููู ุจุดูููุฏุณ ูููุง ุนุงูุฒ ูุนููู ุฅุฒุงู ุชุจูู ุงูู "ุงูุดูุทุฉ" ุฏู ุจุงุณุชุฎุฏุงู ุงูู **Linked List** ูุฏููุงู:

- ูุฃู ุงูู Linked List ูู ุงูููููุฑู ุฃููุฃ ุจูุชูุฑ ูู ุงูุฅุถุงูุฉ ูุงูุญุฐู ุงููุณุชูุฑ.
    
- ุนุดุงู ุชุชุนูู ุฅุฒุงู ุชุชุญูู ูู ุงูู Pointers ุจููุณู ูุชุนุฑู ุงูู `Node** table` ุฏู ุจุชุนูู ุฅูู ุจุงูุธุจุท.
    

```mermaid
graph TD
    subgraph "Hash Table with Chaining"
    T0["table[0]"] --> L0["15 โ 25 โ 35 โ NULL"]
    T1["table[1]"] --> NULL1[NULL]
    T2["table[2]"] --> L2["22 โ 42 โ NULL"]
    T3["table[3]"] --> L3["103 โ NULL"]
    T4["table[4]"] --> NULL4[NULL]
    end
    
    style L0 fill:#4f4,stroke:#333
    style L2 fill:#4f4,stroke:#333
```
---

## 1. The Core Structure (The Foundation)

### **The Problem & Logic**

ูู ุฃู ูุธุงู ุชุฎุฒููุ ุฅุญูุง ูุญุชุงุฌูู "ูุนุงุก" ูุดูู ุงูุฏุงุชุง. ูู ุงุณุชุฎุฏููุง ูุตูููุฉ (Array) ุนุงุฏูุฉุ ูููุงุฌู ูุดููุฉ ุงูุญุฌู ุงููุญุฏูุฏ ูุตุนูุจุฉ ุงูุชุนุงูู ูุน ุงูุจูุงูุงุช ูู ุญุตู ุฒุญูุฉ ูู ููุงู ูุงุญุฏ.

ุงูููุทู ููุง ุฅููุง ุจูุจูู "ูุตูููุฉ ูู ุงูุนูุงููู"ุ ูู ุฎุงูุฉ ูู ุงููุตูููุฉ ูุด ุจุชุดูู ุงููููุฉ ููุณูุงุ ููู ุจุชุดูู ุนููุงู (Pointer) ูุฃูู "ููุฏ" ูู ุณูุณูุฉ ูุฑุชุจุทุฉ (Linked List).

### **The Goal**

ุฅูุดุงุก ูููู ูุฑู ููุฏุฑ ูุชูุณุน "ุฑุฃุณูุงู" (ุนู ุทุฑูู ุงูู Linked List) ููุง ูุญุตู ุชุตุงุฏู ูู ุงูุจูุงูุงุช ูู ููุณ ุงูุฎุงูุฉ.
### ๐๏ธ ูููู ุงูู HashTable

```cpp
class HashTable {
    int size;        // ุนุฏุฏ ุงูุฎุงูุงุช
    Node **table;    // ูุตูููุฉ ูู ุงููุคุดุฑุงุช
    
public:
    HashTable(int size);
    int HashFunction(int key);
    void insert(int key);
    bool search(int key);
    void remove(int key);
    void display();
    ~HashTable();
};
```

```mermaid
graph LR
    subgraph "Memory Layout"
    HT[HashTable Object] --> Size[size: 10]
    HT --> Table[table: 0x1000]
    
    Table --> Array["Node* array[10]"]
    Array --> P0["[0]: 0x2000"]
    Array --> P1["[1]: NULL"]
    Array --> P2["[2]: 0x3000"]
    
    P0 --> Chain1["15 โ 25 โ NULL"]
    P2 --> Chain2["22 โ 42 โ NULL"]
    end
```
 ููุบูุต ุงููุง ูู ุงูููุฏ
### **The Code**



```C++
// Node structure to represent each element in the chain
class Node
{
public:
    int key;    // The actual data/value
    Node *next; // Pointer to the next node in the same bucket/chain

    Node(int key)
    {
        this->key = key;
        this->next = NULL; // Initialize next as NULL to mark the end
    }
};

class HashTable
{
    int size;     // Total number of buckets in the table
    Node **table; // Pointer to an array of Node pointers (The Table)
```

```mermaid
classDiagram
    class Node {
        +int key
        +Node* next
    }
    
    Node1 : key = 15
    Node1 : next = 0x2000
    
    Node2 : key = 25
    Node2 : next = NULL
```
---

## 2. The Constructor (Memory Setup)

### **The Problem & Logic**

ููุง ุจูุญุฌุฒ ูุตูููุฉ ูู ุงูููููุฑู ุจุงุณุชุฎุฏุงู `new` ูู C++ุ ุงูุฎุงูุงุช ูุจูููุด ูููุง ุฃุตูุงุฑุ ุจูุจูู ูููุง "ุฒุจุงูุฉ" (Garbage Values) ุฃู ุนูุงููู ูุฏููุฉ ูุจุฑุงูุฌ ุชุงููุฉ. ูู ุณุจูุงูุง ูุฏุฉุ ุงูุจุฑูุงูุฌ ูููุชูุฑ ุฅู ููู "ููุฏุฒ" ุญููููุฉ ููุฌูุฏุฉ ูููุญุงูู ููุตู ูููุง ููุญุตู `Crash`.

### **The Goal**

ุชุฌููุฒ ุงููุตูููุฉ ูู ุงูู Heap ูุชุตููุฑ ูู ุงูุฎุงูุงุช (Set to `NULL`) ุนุดุงู ูุถูู ุฅู ูู "ุณูุณูุฉ" ุจุชุจุฏุฃ ูู ุงููุฑุงุบ.

### **The Code**



```C++
public:
    HashTable(int size)
    {
        this->size = size;
        // Step 1: Allocate an array of 'Node pointers' in the Heap
        table = new Node *[size];

        // Step 2: Initialize each pointer to NULL to avoid wild pointers
        for (int i = 0; i < size; i++)
        {
            table[i] = NULL; 
        }
    }
```

---

## 3. The Hash Function (The Mapping Logic)

### **The Problem & Logic**

ุฅุญูุง ุนูุฏูุง ููุงุชูุญ (Keys) ูููู ุชููู ุฃู ุฑูู (ูุซูุงู ูู 1 ูุญุฏ ููููู)ุ ููู ุนูุฏูุง ูุณุงุญุฉ ูุญุฏูุฏุฉ ูู ุงููุตูููุฉ (ูุซูุงู 10 ุฎุงูุงุช ููุท). ุฅุฒุงู ูุฎูู ุฃู ุฑูู ูุจูุฑ "ูุตุบุฑ" ููุฏุฎู ุฌูู ุญุฏูุฏ ุงููุตูููุฉ (ูู 0 ูู 9)ุ

ุงูููุทู ูู ุงุณุชุฎุฏุงู **ุจุงูู ุงููุณูุฉ (Modulo)**ุ ูุฃู ูุงุชุฌ `X % 10` ุฏุงููุงู ููููู ุฑูู ุจูู 0 ู 9.

### **The Goal**

ุชุญููู ุงูู Key ูู Index "ูุงูููู" ูุตุญูุญ ููุน ุฏุงุฎู ูุทุงู ุงููุตูููุฉ ุงููุญุฌูุฒุฉ.

### **The Code**



```C++
    // Transforms the key into a valid array index
    int HashFunction(int key)
    {
        // Using modulo operator to keep the index within [0 to size-1]
        int index = key % size; 
        return index;
    }
```

---

## 4. The Insertion Logic (Handling Collisions)

### **The Problem & Logic**

ุฏูููุชู ุญุณุจูุง ุงูู Index ูุทูุน ูุซูุงู "0". ุฑุญุช ููุฎุงูุฉ ุฑูู 0 ูููุช ูููุง ูุนูุงู "ููุฏ" ูุฏููุฉ (ุชุตุงุฏู). ุงูููุทู ุงูุฃุณุฑุน ูุงูุฃุฐูู ูู ุฅููุง ูุด ุจูุฏูุฑ ุนูู ุขุฎุฑ ุงูุณูุณูุฉ ุนุดุงู ูุถููุ ุฅุญูุง ุจูุถูู ุงูููุฏ ุงูุฌุฏูุฏุฉ ูู ุฃูู ุงูุณูุณูุฉ (At the Head).

ูููุ ูุฃู ุงูุฅุถุงูุฉ ูู ุงูุฃูู ุจุชุงุฎุฏ ุฎุทูุฉ ูุงุญุฏุฉ ุจุณ $O(1)$ุ ููู ูู ุฏูุฑุช ุนูู ุงูุขุฎุฑ ูุชุงุฎุฏ ููุช $O(n)$.

### **The Goal**

ุฅุถุงูุฉ ุงูููุฏ ุงูุฌุฏูุฏุฉ ูู ุงูุฎุงูุฉ ุงูููุงุณุจุฉ ูุฑุจุทูุง ุจุงูุณูุณูุฉ ุงูููุฌูุฏุฉ ูุณุจูุงู (ุฅู ูุฌุฏุช) ุจุฏูู ุถูุงุน ุงูุจูุงูุงุช ุงููุฏููุฉ.

### **The Code**



```C++
    void insert(int key)
    {
        // Step 1: Create the new node in memory
        Node *newNode = new Node(key);

        // Step 2: Determine which bucket/index it belongs to
        int index = HashFunction(key);

        // Step 3: Insert at the beginning of the linked list
        // Make the new node point to whatever is currently at that index
        newNode->next = table[index];

        // Step 4: Update the table index to point to the new node
        table[index] = newNode;
    }
```

---
## deep dive in the insert function:

### **1. ุงูููุทู ูุงููุฏู (The Logic & Goal)**

ุงููุฏู ุฅููุง ูุญุท ุงูููุฏ ุงูุฌุฏูุฏุฉ ูู **ุฃูู ุงูุทุงุจูุฑ** (Head of the list).

- **ุงููุดููุฉ:** ูู ุฌูุช ูุฎููุช "ููุจุถ ุงูุจุงุจ" (`table[index]`) ููุณู ุฅูุฏ ุงูููุฏ ุงูุฌุฏูุฏุฉ ููุฑุงูุ ุฅูุช ูุฏุฉ ุณูุจุช ุฅูุฏ ุงููุงุณ ุงููู ูุงูุช ูุงููุฉ ูุฏููุ ูููุชูููุง ูู ุงูููููุฑู (Memory Leak).
    
- **ุงูุญู:** ุงูููุฏ ุงูุฌุฏูุฏุฉ ูุงุฒู ุชูุณู ุฅูุฏ "ุฃูู ูุงุญุฏ ูุฏูู" ุงูุฃููุ ูุจุนุฏูู ุฅุญูุง ูููู "ููุจุถ ุงูุจุงุจ" ููููุฏ ุงูุฌุฏูุฏุฉ.
    

---

### **2. ุชุชุจุน ุงูุฎุทูุงุช ุจุงูุฑุณู (Step-by-Step Trace)**

ูุชุฎูู ุฅู ุงูู `index` ูู **0**ุ ูุฅุญูุง ุจูุถูู ุงูุฑูู **20**ุ ููุงู ููู ุฃุตูุงู ุงูุฑูู **10** ููุฌูุฏ ูุจู ูุฏุฉ.

#### **ุงูุญุงูุฉ ูุจู ุงูุฅุถุงูุฉ:**

- `table[0]` ุจูุดุงูุฑ ุนูู ุงูููุฏ **10**.
    
- ุงูููุฏ **10** ุจุชุดุงูุฑ ุนูู `NULL`.
    

#### **ุงูุฎุทูุฉ 3: `newNode->next = table[index];`**

ุฅุญูุง ุนูููุง ููุฏ ุฌุฏูุฏุฉ ุงุณููุง **20**. ุฏูููุชู ุจูููู ููู **20**: "ูุง 20ุ ุฎูู ุงูู `next` ุจุชุงุนู ููุณู ุงููู ุงูู `table[0]` ูุงุณูู ุฏูููุชู".

- **ุงููุชูุฌุฉ:** ุงูููุฏ **20** ุจูุช ูุงุณูุฉ ุฅูุฏ ุงูููุฏ **10**.
    
- **ูุงุญุธ:** ุงูู `table[0]` ูุณู ูุงุณู ุงูู **10** ุจุฑุถู.. ุฅุญูุง ูุฏุฉ ุนูููุง "ูุตูุฉ ูุคูุชุฉ".
    

#### **ุงูุฎุทูุฉ 4: `table[index] = newNode;`**

ุฏูููุชู ููุฏุฑ ูููู "ููุจุถ ุงูุจุงุจ" ุจุฃูุงู. ุจูููู ููู `table[0]`: "ุณูุจ ุงูู 10ุ ูุงูุณู ุงูููุฏ ุงูุฌุฏูุฏุฉ **20**".

- **ุงููุชูุฌุฉ ุงูููุงุฆูุฉ:** `table[0]` -> **20** -> **10** -> `NULL`.
    

---

### **3. ุชุฎูููุง ุจู Mermaid (ุณูุณูุฉ ุงูุฅุถุงูุฉ)**

 ุงูุฑุณู ูู ุฃุญุณู ูุณููุฉ ูุชุซุจูุช ุงูู Pointers ูู ุงูุฏูุงุบ. ุชุนุงู ูุชุฎูู ุฅููุง ุจูุถูู ุงูููุฏ **20** ูู ุฌุฏูู ุญุฌูู **5**ุ ููุงู ุงูุฌุฏูู ุฏู ููู ุฃุตูุงู ุงูููุฏ **10** ุนูุฏ ุงูู Index ุฑูู **0**.

ุณุฃูุณู ูู ุงูุนูููุฉ ูู **4 ููุทุงุช** (Frames) ูุฃููุง ุจูุตูุฑ ูููู ุณูููุงุฆู ููููููุฑู.

---

### **ุงูุฎุทูุฉ 0: ุงูุญุงูุฉ ูุจู ุงูุฅุถุงูุฉ (The Initial State)**

ุงูุฌุฏูู ููู ุงูููุฏ **10**ุ ูุงูู `table[0]` ูุดุงูุฑ ุนูููุง.

Code snippet

```mermaid
graph LR
    Table["table[0] (Pointer)"] -- points to --> Node10((Node 10))
    Node10 -- next --> NULL1[NULL]

    style Table fill:#f9f,stroke:#333
```

---

### **ุงูุฎุทูุฉ 1 ู 2: ุฅูุดุงุก ุงูููุฏ ุงูุฌุฏูุฏุฉ (Node Creation)**

ุงูููุฏ: Node *newNode = new Node(20); ู int index = HashFunction(20);.

ุฏูููุชู ุนูุฏูุง ููุฏ "ุชุงููุฉ" ูู ุงูููููุฑู ูุณู ูููุงุด ุนูุงูุฉ ุจุงูุฌุฏูู.



```mermaid
graph LR
    subgraph "Main Table"
    Table["table[0]"] --> Node10((Node 10))
    Node10 --> NULL1[NULL]
    end

    subgraph "New Memory Space"
    NewNode((New Node 20)) -- next --> NULL2[NULL]
    end

    style NewNode fill:#f96,stroke:#333,stroke-width:4px
```

---

### **ุงูุฎุทูุฉ 3: ุงูุชูุตูู ุงูุขูู (newNode->next = table[index])**

ุฏู ุฃูู ููุทุฉ. ุฅุญูุง ุจูููู ููููุฏ **20**: "ูุง 20ุ ูุตูู ุงูู `next` ุจุชุงุนู ุจุงููู ุงูู `table[0]` ูุงุณูู ุญุงููุงู (ุงููู ูู ุงูู 10)".

> **ูุงุญุธ:** ุงูู `table[0]` ูุณู ูุดุงูุฑ ุนูู ุงูู 10ุ ูุงูู 20 ุจุฑุถู ุจูุช ูุดุงูุฑุฉ ุนูู ุงูู 10. ูููุด ุฏุงุชุง ุถุงุนุช!



```mermaid
graph LR
    Table["table[0]"] --> Node10((Node 10))
    NewNode((New Node 20)) -- "next = table[0]" --> Node10
    Node10 --> NULL1[NULL]

    style NewNode fill:#f96,stroke:#333
    style Table fill:#f9f,stroke:#333
```

---

### **ุงูุฎุทูุฉ 4: ุชุญุฏูุซ ุฑุฃุณ ุงูุฌุฏูู (table[index] = newNode)**

ุขุฎุฑ ููุทุฉ. ุฏูููุชู ุจูููู "ุงูุฎูุท" ุจุชุงุน `table[0]` ุนุดุงู ููุณู ุงูููุฏ ุงูุฌุฏูุฏุฉ **20**.



```mermaid
graph LR
    Table["table[0]"] -- "now points here" --> NewNode((Node 20))
    NewNode -- next --> Node10((Node 10))
    Node10 --> NULL1[NULL]

    style NewNode fill:#f96,stroke:#333
    style Table fill:#f9f,stroke:#333
```

---

### **ููุงุฐุง ูุฐู ุงูุทุฑููุฉ ุนุจูุฑูุฉุ**

1. **ุงูุณุฑุนุฉ ($O(1)$):** ูููุง ูุงู ุทูู ุงูุณูุณูุฉ (Chain) ุงููู ุนูุฏ ุงูู Index ุฑูู 0ุ ุฅูุช ุฏุงููุงู ุจุชุนูู ุงูุฎุทูุงุช ุฏู ูู ููุณ ุงูููุช. ูุด ูุญุชุงุฌ ุชูุดู ูุขุฎุฑ ุงูุณูุณูุฉ ุนุดุงู ุชุถูู.
    
2. **ุงูุฃูุงู:** ูู ููุช ููุฐุช ุงูุฎุทูุฉ 4 ูุจู ุงูุฎุทูุฉ 3ุ ููุช ูุชูุทุน ุงูุฎูุท ุงููู ูุงุตู ููููุฏ 10ุ ููุชุถูุน ููู ููุฃุจุฏ ูู ุงูููููุฑู.
    

---

### **ุชุญุฏู ุงูู Trace ุงูุฌุงู:**

ุชุฎูู ูู ุถููุง ููุฏ ุชุงูุชู ูููุชูุง **30** ุนูุฏ ููุณ ุงูู Index (0).

1. ููู ุงููู ุงูู `next` ุจุชุงุนู ููุดุงูุฑ ุนูู ุงูู **20**ุ
    
2. ุงูู `table[0]` ููุดุงูุฑ ุนูู ููู ูู ุงูุขุฎุฑุ
    

---

### **4. ูุงุฐุง ูู ุนูุณูุง ุงูุณุทุฑููุ (The Disaster)**

ูู ูุชุจุช ูุฏุฉ:

1. `table[index] = newNode;`
    
2. `newNode->next = table[index];`
    

- **ุงููุงุฑุซุฉ:** ูู ุงูุณุทุฑ ุงูุฃููุ ุฅูุช ุฎููุช `table[index]` ููุณู ุงูููุฏ ุงูุฌุฏูุฏุฉุ ูููุฏุช "ููุฃุจุฏ" ุนููุงู ุงูููุฏ ุงููุฏููุฉ ุงููู ูุงูุช ููุฌูุฏุฉ.
    
- ุงูุณุทุฑ ุงูุชุงูู ููุฎูู ุงูููุฏ ุชุดุงูุฑ ุนูู "ููุณูุง"ุ ููุชุนูู `Infinite Loop` ูุงูุจุฑูุงูุฌ ููููุฌ.
    

---

### **5. ุงูููุฏ ุจุงูููููุชุงุช ุงูุชูุตูููุฉ (The Code)**



```C++
void insert(int key)
{
    // Step 1: Create the new node
    Node *newNode = new Node(key);

    // Step 2: Get the bucket index
    int index = HashFunction(key);

    // Step 3: Secure the existing chain
    // Tell newNode: "Don't lose the people already in line!"
    // Point newNode's next to the current first node in this bucket
    newNode->next = table[index];

    // Step 4: Make newNode the new head
    // Now that the chain is secure, update the table to point to our newNode
    table[index] = newNode;
}
```

### **ุงูุฎูุงุตุฉ (The Takeaway):**

ุฅุญูุง ุฏุงููุงู ุจูุฑุจุท **"ูู ุงูุฌุฏูุฏ ูููุฏูู"** ุงูุฃููุ ูุจุนุฏูู ุจูุญุฏุซ **"ุนููุงู ุงูุจุฏุงูุฉ"**. ุฏู ูู ุณุฑ ุงูู $O(1)$ Insertionุ ูุฃูู ูุด ูุญุชุงุฌ ุชูุดู ูุขุฎุฑ ุงูุทุงุจูุฑ ุนุดุงู ุชุถููุ ุฅูุช ุฏุงููุงู ุจุชุจูู ูู "ูุฏุงู".


---

## 5. The Search Logic (Finding the Needle)

### **The Problem & Logic**

ุฅุญูุง ูุด ุนุงูุฒูู ูุฏูุฑ ูู ุงูุฌุฏูู ูููุ ุฏู ุชุถููุน ููุช. ุงูููุทู ุจูููู: "ูู ุงูุฑูู ุฏู ููุฌูุฏุ ูุณุชุญูู ูููู ูู ุฃู ุญุชุฉ ุชุงููุฉ ุบูุฑ ุงูู Index ุงููู ูุนุงุฏูุชู ุจุชููู ุนููู".

ูุฅุญูุง ุจูุญุณุจ ุงูู Indexุ ูุจูุฑูุญ ููุฎุงูุฉ ุฏู ุจุงูุธุจุทุ ููุจุฏุฃ ูุชูุดู ุฌูู ุงูุณูุณูุฉ ุงูุตุบูุฑุฉ ุงููู ููุงู ุจุณ.

### **The Goal**

ุงูุชุฃูุฏ ูู ูุฌูุฏ ุงูู Key ูู ุฃุณุฑุน ููุช ูููู ($O(1)$ ูู ุงููุชูุณุท).

### **The Code**



```C++
bool search(int key)
{
    // Step 1: Calculate the exact bucket index
    int index = HashFunction(key);

    // Step 2: Start a pointer at the head of this bucket's list
    Node *curr = table[index];

    // Step 3: Traverse the small chain (Linked List)
    while (curr != NULL)
    {
        // If we found it, return true immediately
        if (curr->key == key)
        {
            return true;
        }
        // Move to the next person in line
        curr = curr->next;
    }
    // If we finished the list and didn't find it
    return false;
}
```

## ูุซุงู:

ุชุฎูู ุฅููุง ุจูุฏูุฑ ุนูู ุงูุฑูู **5** ูู ุฌุฏูู ุญุฌูู **10**ุ ูุงูู Index ุฑูู **5** ุดุงูู ุงูุณูุณูุฉ ุฏู: `15 -> 5 -> 25 -> NULL`.

---

### ุงูุฎุทูุฉ 1: ุญุณุงุจ "ุงูุฅุญุฏุงุซูุงุช" (Hashing)

ุฃูู ุญุงุฌุฉุ ุงูุจุฑูุงูุฌ ูุด ุจูุชุญุฑู ูู ููุงูู ุบูุฑ ููุง ูุนุฑู ููุฑูุญ ููู ุจุงูุธุจุท.

- **ุงููุนุงุฏูุฉ:** $index = 5 \pmod{10} = 5$.
    
- **ุงููุฏู:** ุงูููุฒ ูุจุงุดุฑุฉ ููุฎุงูุฉ ุฑูู 5 ูู ุงููุตูููุฉ.
    



```mermaid
graph LR
    Input((Key: 5)) -- "HashFunction(5)" --> Index["Index: 5"]
    Index -- "Direct Access" --> Bucket5["table[5]"]
    
    style Index fill:#f96,stroke:#333
    style Bucket5 fill:#f9f,stroke:#333
```

---

### ุงูุฎุทูุฉ 2: ูุถุน "ุงูููุญูู" (Pointer Initialization)

ุจูุฌุฑุฏ ูุง ูุตููุง ููู Index ุฑูู 5ุ ุจูููู ูุคุดุฑ ุงุณูู `curr` ุนูุฏ ุฃูู ููุฏ ูู ุงูุณูุณูุฉ.

- **ุงูููุฏ:** `Node *curr = table[index];`
    



```mermaid
graph TD
    Table[table Index 5] --> N15((15))
    N15 --> N5((5))
    N5 --> N25((25))
    N25 --> NULL[NULL]

    CurrPtr[curr Pointer] -- "starts here" --> N15
    
    style CurrPtr fill:#bbf,stroke:#333
```

---

### ุงูุฎุทูุฉ 3: ุงูุชูุชูุด - ุงูุฌููุฉ ุงูุฃููู (Comparison 1)

ุงููุญูู `curr` ุจูุณุฃู ุงูููุฏ ุงููู ูุงูู ุนูุฏูุง: "ูู ุงูู Key ุจุชุงุนู ูู 5ุ".

- **ุงูุญุงูุฉ:** `15 != 5`.
    
- **ุงูุฃูุฑ:** "ุงุชุญุฑู ููู ุจุนุฏูุง" -> `curr = curr->next;`.
    

Code snippet

```mermaid
graph TD
    Table[table Index 5] --> N15((15))
    N15 --> N5((5))
    N5 --> N25((25))
    
    CurrPtr[curr Pointer] -- "Checks 15: No Match" --> N15
    CurrPtr -. "Moves to next" .-> N5

    style N15 fill:#fff,stroke:#f66
```

---

### ุงูุฎุทูุฉ 4: ุงูุชูุชูุด - ุงูุฌููุฉ ุงูุซุงููุฉ (Success!)

ุงููุญูู `curr` ุฏูููุชู ูุงูู ุนูุฏ ุงูููุฏ ุงูุชุงููุฉ ูุจูุณุฃู ููุณ ุงูุณุคุงู: "ูู ุงูู Key ุจุชุงุนู ูู 5ุ".

- **ุงูุญุงูุฉ:** `5 == 5`.
    
- **ุงููุชูุฌุฉ:** ูุจุฑูู! ููููุง ุงููุฏู. ุงูุจุฑูุงูุฌ ุจูุฑุฌุน `true` ููููู ุจุญุซ ููุฑุงู.
    

Code snippet

```mermaid
graph TD
    Table[table Index 5] --> N15((15))
    N15 --> N5((5))
    N5 --> N25((25))
    
    CurrPtr[curr Pointer] -- "Checks 5: MATCH!" --> N5
    
    style N5 fill:#4f4,stroke:#333,stroke-width:4px
    style CurrPtr fill:#bbf,stroke:#333
```

---

### ูุงุฐุง ูู ูู ููู ุงูุฑูู ููุฌูุฏุงูุ (The Fail Scenario)

ูู ููุง ุจูุฏูุฑ ุนูู ุฑูู **99**:

1. ุงูู `index` ููููู $99 \pmod{10} = 9$.
    
2. ููุฑูุญ ูู `table[9]` ููุงูููุง `NULL` ุฃู ููู ูู ุงูุณูุณูุฉ ุจุชุงุนุชูุง ูุญุฏ ูุง ุงูู `curr` ูุจูู ุจู `NULL`.
    
3. ุฃูู ูุง ุงูู `curr == NULL` ูุฎุฑุฌ ูู ุงูู `while` ููุฑุฌุน `false`.
    

---

### ุชุญููู ุงูุฐูุงุก ูู ูุฐู ุงูุนูููุฉ:

- **ููุงุฐุง ูู $O(1)$ุ** ูุฃูู ูุทูุช ููู Index 5 ูู ุฎุทูุฉ ูุงุญุฏุฉุ ูุงูู Linked List ุงููู ุฌูู ุงูุฎุงูุฉ ุนุงุฏุฉู ุจุชููู ูุตูุฑุฉ ุฌุฏุงู (ููุฏ ุฃู ุงุชููู).
    
- **ููุงุญุธุฉ ุฌุฑุงุญูุฉ:** ูุงุญุธ ุฅููุง ููุฏุฑูุงุด ูุณุชุฎุฏู Binary Search ุฌูู ุงูุณูุณูุฉ ุฏู ูุฃููุง Linked Listุ ูุฅุญูุง ูุณู ูุงูููู ูู ุงูุชูุฑูุฑ ุจุชุงุน ุงูู Lab ุฅู ุงูู Binary Search ุณูุฆ ูุน ุงูู Linked List.
    

---

## 6. The Removal Logic (The Surgical Bypass)

### **The Problem & Logic**

ุงูุญุฐู ูู ุฃุตุนุจ ุฌุฒุก ูุฃููุง ูู ุดูููุง ููุฏ ูู ูุต ุงูุณูุณูุฉุ ุงูุณูุณูุฉ ูุชุชูุทุน.

ุงูููุทู: ูุงุฒู ูููู ูุนุงูุง "ุงุชููู ูุญูููู"ุ ูุงุญุฏ ูุงุณู ุงูููุฏ ุงููู ูููุณุญูุง (curr) ููุงุญุฏ ูุงุณู ุงูููุฏ ุงููู ูุจููุง (prev) ุนุดุงู ููุง ูุดูู ุงูู curr ูุฑุจุท ุงูู prev ุจุงููู ูุงู ุจุนุฏ ุงูู curr ูุจุงุดุฑุฉ.

### **The Goal**

ุญุฐู ุงูููุฏ ูุชุญุฑูุฑ ูุณุงุญุชูุง ูู ุงูููููุฑู ูุน ุงูุญูุงุธ ุนูู ุงุชุตุงู ุงูุณูุณูุฉ.

### **Mermaid: The Removal Surgery (Case: Middle Node)**

ุชุฎูู ุจููุณุญ ููุฏ **5** ุงููู ููุฌูุฏุฉ ุจูู **15** ู **20**:



```mermaid
graph LR

    subgraph "The Surgery: Bypassing 5"
    T2[table index] --> N15_2((15: prev))
    N15_2 -- "prev->next = curr->next" --> N20_2((20))
    N5_2((5: curr)) -- "to be deleted" --> X[X]
    end
    
    subgraph "Before Deleting 5"
    T[table index] --> N15((15: prev))
    N15 --> N5((5: curr))
    N5 --> N20((20: next))
    end



    style N5 fill:#f66,stroke:#333
    style N5_2 fill:#f66,stroke:#333
```

### **The Code**



```C++
void remove(int key)
{
    int index = HashFunction(key);
    Node *curr = table[index]; // The node we are checking
    Node *prev = NULL;         // The node just before 'curr'

    while (curr != NULL)
    {
        if (curr->key == key) // We found our target!
        {
            // Case 1: Target is the first node (Head)
            if (prev == NULL)
            {
                table[index] = curr->next; // Point the table to the second node
            }
            // Case 2: Target is in the middle or end
            else
            {
                prev->next = curr->next; // The bridge: skip 'curr'
            }
            delete curr; // Free memory to avoid leaks
            return;      // Task finished
        }
        // Move both pointers forward
        prev = curr;
        curr = curr->next;
    }
}
```

## ูุซุงู


 ุนูููุฉ ุงูุญุฐู (**Remove**) ูู ุงูู Hash Table ูู "ุนูููุฉ ุฌุฑุงุญูุฉ" ุฏูููุฉ ุฌุฏุงู. ูููุ ูุฃููุง ูู ูุณุญูุง ููุฏ ูู ูุณุท ุงูุณูุณูุฉ (Chain) ูู ุบูุฑ ูุง ูุฑุจุท ุงููู ูุจููุง ุจุงููู ุจุนุฏูุงุ ุงูุณูุณูุฉ ูููุง ูุชุชูุทุน ููุฎุณุฑ ุจูุงูุงุชูุง.

ุจุดูููุฏุณ ูููุง ุงุณุชุฎุฏู ุงุณุชุฑุงุชูุฌูุฉ **"ุงูููุญูู ูุงูููุณุงุนุฏ"** (`curr` ู `prev`) ุนุดุงู ูุถูู ุฅู ุงูุนูููุฉ ุชุชู ุจูุฌุงุญ. ุชุนุงู ูุชุฎูู ุฅููุง ุจููุณุญ ุงูุฑูู **20** ูู ุณูุณูุฉ ูููุง `15 -> 20 -> 25 -> NULL`.

---

### 1. ุงูุชุฌููุฒ ููุนูููุฉ (The Setup)

ูู ุงูุจุฏุงูุฉุ ุจูููู ุงูู `curr` ุนูุฏ ุฃูู ููุฏุ ูุงูู `prev` ุจูุจุฏุฃ ูู "ุงูุนุฏู" (`NULL`).

- **ุงูููุฏ:** `Node *curr = table[index]; Node *prev = NULL;`
    



```mermaid
graph TD
    Table[table Index] --> N15((15))
    N15 --> N20((20))
    N20 --> N25((25))
    N25 --> NULL[NULL]

    CurrPtr[curr] -- "Target Finder" --> N15
    PrevPtr[prev] -- "Safety Bridge" --> NullBox[NULL]
    
    style CurrPtr fill:#f96,stroke:#333
    style PrevPtr fill:#bbf,stroke:#333
```

---

### 2. ุงูุจุญุซ ุนู ุงููุฏู (The Search Phase)

ุจูุจุฏุฃ ูุชุญุฑู. ุทุงููุง ุงูู `curr` ูุด ูู ุงููุฏูุ ุงูู `prev` ุจูุงุฎุฏ ููุงู ุงูู `curr` ุงููุฏููุ ูุงูู `curr` ุจููุดู ุฎุทูุฉ ููุฏุงู.

- **ุงูุขู:** `curr` ูุงูู ุนูุฏ **20** (ุงููุฏู)ุ ูุงูู `prev` ูุงูู ุนูุฏ **15**.
    



```mermaid
graph TD
    Table[table Index] --> N15((15))
    N15 --> N20((20))
    N20 --> N25((25))

    PrevPtr[prev] --> N15
    CurrPtr[curr] -- "MATCH FOUND!" --> N20
    
    style N20 fill:#f66,stroke:#333,stroke-width:4px
    style PrevPtr fill:#bbf,stroke:#333
    style CurrPtr fill:#f96,stroke:#333
```

---

### 3. ุงูุฑุจุท ุงูุฌุฑุงุญู (The Bridge/Bypass)

ููุง ุงููุญุธุฉ ุงูุญุงุณูุฉ. ุฅุญูุง ุนุงูุฒูู ูุดูู ุงูู 20 ุจุณ ูุงุฒู ุงูู 15 ุชูุณู ูู ุงูู 25 ุงูุฃูู.

ุจูุง ุฃู ุงูู prev ูุด ุจู NULL (ุฅุญูุง ูุด ูู ุฃูู ููุฏ)ุ ุจูููู ููู prev: "ูุง 15ุ ุฎูู ุงูู next ุจุชุงุนู ููุณู ุงููู ุจุนุฏ ุงูู 20".

- **ุงูููุฏ:** `prev->next = curr->next;`
    



```mermaid
graph TD
    Table[table Index] --> N15((15))
    N15 -- "The Bypass Bridge" --> N25((25))
    N20((20)) -. "Link Broken" .-> N25
    N25 --> NULL[NULL]

    style N20 fill:#ddd,stroke:#999,stroke-dasharray: 5 5
    style N15 fill:#4f4,stroke:#333
```

---

### 4. ุชูุธูู ุงูููููุฑู (The Disposal)

ุฏูููุชู ุงูููุฏ **20** ุจูุช "ูุนุฒููุฉ" ุชูุงูุงู. ููุฏุฑ ููุณุญูุง ูู ุงูููููุฑู ููุฑุงู.

- **ุงูููุฏ:** `delete curr;`
    



```mermaid
graph TD
    Table[table Index] --> N15((15))
    N15 --> N25((25))
    N25 --> NULL[NULL]
    
    Deleted[Deleted Node 20] --- X[MEMORY FREED]

    style Deleted fill:#000,stroke:#f00,color:#fff
```

---

### ุงูุญุงูุฉ ุงูุฎุงุตุฉ: ุญุฐู ุฃูู ููุฏ (Removing the Head)

ูู ูุงู ุงูุฑูู ุงููู ุจููุณุญู ูู **15** (ุฃูู ูุงุญุฏ)ุ ุงูู `prev` ูููุถู `NULL`. ูู ุงูุญุงูุฉ ุฏูุ ุจูุฎูู ุงูู `table[index]` ููุณู ูุดุงูุฑ ุนูู ุงูููุฏ ุงูุชุงููุฉ ููุฑุงู.

- **ุงูููุฏ:** `if (prev == NULL) { table[index] = curr->next; }`
    

---

### ููุฎุต ุงูุนูููุฉ ุงูุฌุฑุงุญูุฉ:

1. **ูู ุงููุฏู ุฃูู ููุฏ:** ุบูุฑ ุนููุงู ุงูุจุฏุงูุฉ ูู ุงูุฌุฏูู (`table[index]`).
    
2. **ูู ุงููุฏู ูู ุงููุต:** ุฎูู ุงููู ูุจูู (`prev`) ููุณู ูู ุงููู ุจุนุฏู (`curr->next`).
    
3. **ูู ูู ุงูุฃุญูุงู:** ูุงุฒู ุชุนูู `delete curr` ุนุดุงู ูุชุณูุจุด ุฒุจุงูุฉ ูู ุงูููููุฑู.
    



---

## 7. The Destructor (The Cleaning Service)

### **The Problem & Logic**

ุงูู Hash Table ุฏู ุญุงุฌุฒุฉ ูุณุงุญุฉ ูุจูุฑุฉ ูู ุงูู **Heap** (ุงููุตูููุฉ + ูู ุงูููุฏุฒ). ูู ููููุง ุงูุจุฑูุงูุฌ ูู ุบูุฑ ูุง ููุณุญููุ ุงูููููุฑู ูุชุชููู ุฒุจุงูุฉ (Memory Leak).

### **The Goal**

ูุณุญ ูู ููุฏ ูู ูู ุณูุณูุฉุ ูุจุนุฏูู ูุณุญ ุงููุตูููุฉ ููุณูุง.

### **The Code**



```C++
~HashTable()
{   
    // Loop through every bucket in the table
    for (int i = 0; i < size; i++)
    {
        Node *curr = table[i];
        // Delete the entire linked list in this bucket
        while (curr != NULL)
        {
            Node *temp = curr;
            curr = curr->next;
            delete temp; // Free each node
        }
    }
    // Finally, delete the array of pointers itself
    delete[] table; 
}
```

---


ุจุต ูุง ูุญูุฏุ ุงููุณุฃูุฉ ุฏู (LeetCode 141) ูู ุฃุดูุฑ ูุณุงุฆู ุงูููุงุจูุงุช ุงูุชูููุฉุ ูุงุณุชุฎุฏุงู ุงูู **Hash Table** ูููุง ูู ุงูุญู ุงูุฃูุซุฑ ููุทููุฉ ูุฐูุงุกู ูุฃูู ุจูุนุชูุฏ ุนูู "ุงูุฐุงูุฑุฉ".

---

### 1. ูุบุฒ ุงูุฏุงุฆุฑุฉ (The Concept)

ุชุฎูู ุฅูู ูุงุดู ูู ุทุฑูุฉ ุทูููุฉ ุถููุฉุ ูุนุงูุฒ ุชุนุฑู ูู ุงูุทุฑูุฉ ุฏู ุจุชูู ูุชุฑุฌุนู ูููุณ ุงูููุงู ุชุงูู (Cycle) ููุง ูู ุทุฑูุฉ ูุณุชูููุฉ ููููุง ููุงูุฉุ

- **ุงูุญู:** ูู ูุง ุชุนุฏู ุนูู "ุจูุงุทุฉ" (ููุฏ)ุ ูุชุฑุณู ุนูููุง ุนูุงูุฉ ุฃู ูุชุณุฌู ุฑูููุง ูู "ููุชุฉ" ูุนุงู.
    
- ูู ุฌูุช ุชุณุฌู ุฑูู ุจูุงุทุฉ ููููุช ุฅู ุงูุฑูู ุฏู **ููุชูุจ ูุนูุงู ูู ุงูููุชุฉ**ุ ูุจูู ุฅูุช "ูููุช ูุฑุฌุนุช" ูููุณ ุงูููุทุฉ!
    

---

### 2. ุชุฎูู ุงูู Cycle ุจู Mermaid

ุฏู ุดูู ุงูู Linked List ุงููู ูููุง ููุฉ (1 ูุฑูุญ ูู 2ุ 2 ูู 3ุ 3 ูู 4ุ ู4 ุชุฑุฌุน ูู 2 ุชุงูู):

Code snippet

```
graph LR
    N1((1)) --> N2((2))
    N2 --> N3((3))
    N3 --> N4((4))
    N4 -- "Cycle!" --> N2
    
    style N2 fill:#f96,stroke:#333
```

---

### 3. ุชุดุฑูุญ ุฏุงูุฉ ุงูู `hasCycle` (ุงูุฌุฒุก ุงูุฃุฎูุฑ ูู ุงูููุฏ)

ุจุดูููุฏุณ ูููุง ุนูู ุงูุขุชู:

1. **ุฅูุดุงุก ุงูุฐุงูุฑุฉ:** ุนุฑู `HashTable ht(1000);` ุฏู ุงูู "ููุชุฉ" ุงููู ููุณุฌู ูููุง.
    
2. **ุงููุทุงุฑุฏุฉ:** ุจุฏุฃ `while loop` ูุชูุดู ูููุง ุนูู ุงูููุฏุฒ ูุงุญุฏุฉ ูุงุญุฏุฉ.
    
3. **ุงูุชูุชูุด:** ูุจู ูุง ูุฏุฎู ุฃู ููุฏุ ุจูุนูู `ht.search(curr->key)`.
    
    - ูู ุฑุฌุนุช `true`: ูุจูู ุงูููุฏ ุฏู ุดููุงูุง ูุจู ูุฏุฉุ ุฅุฐู ููู **Cycle**.
        
    - ูู ุฑุฌุนุช `false`: ูุจูู ุฃูู ูุฑุฉ ูุดูููุงุ ูุจูุนูู ูููุง `ht.insert(curr->key)` ููููู ููู ุจุนุฏูุง.
        

---

### 4. ุชุชุจุน ุงูุฎุทูุงุช (Step-by-Step Trace)

ููุทุจู ูุฐุง ุนูู ุงูุฑุณูุฉ ุงููู ููู (1 -> 2 -> 3 -> 4 -> 2):

|**ุงูุฎุทูุฉ**|**ุงูููุฏ ุงูุญุงููุฉ (curr)**|**ูู ููุฌูุฏุฉ ูู ุงูู HashTableุ**|**ุงููุฑุงุฑ**|
|---|---|---|---|
|**1**|ููุฏ (1)|ูุง (`false`)|ุถูู (1) ูู ุงูุฌุฏูู ูููู.|
|**2**|ููุฏ (2)|ูุง (`false`)|ุถูู (2) ูู ุงูุฌุฏูู ูููู.|
|**3**|ููุฏ (3)|ูุง (`false`)|ุถูู (3) ูู ุงูุฌุฏูู ูููู.|
|**4**|ููุฏ (4)|ูุง (`false`)|ุถูู (4) ูู ุงูุฌุฏูู ูููู.|
|**5**|ููุฏ (2) **"ุชุงูู"**|**ูุนู (`true`)!**|ููู! ุงุฑุฌุน `true` (ููู ููุฉ).|

---

### 5. ููุงุญุธุฉ "ุฌุฑุงุญูุฉ" ูููุญุชุฑููู

ูู ุงูููุฏ ุฏูุ ุจุดูููุฏุณ ูููุง ุจูุฎุฒู ุงูู `key` (ุงููููุฉ).

- **ุชูุจูู:** ูู ุงูุญูููุฉุ ูู ุงูู List ูููุง ุฑูููู "5" (ูุซูุงู 5 -> 6 -> 5)ุ ุงูููุฏ ุฏู ูููู ููุชูุฑ ุฅู ููู Cycle ููู ูููุด.
    
- **ุงูุชุนุฏูู ุงูุงุญุชุฑุงูู:** ุงูุฃูุถู ุฅููุง ูุฎุฒู **ุนููุงู ุงูููุฏ (Address)** ูู ุงูู HashTable ุจุฏู ูููุชูุงุ ูุฃู ุงูุนููุงู ูุณุชุญูู ูุชูุฑุฑ ูููุฏ ุชุงููุฉุ ูุฏู ุงููู ุจูุฎูู ุงูู Hashing ููุง ุนุจูุฑู.
    

---

### 6. ููู ุงูู Hashing ููุง ุจุทูุ

ูุฃู ุนูููุฉ ุงูุจุญุซ (`search`) ูุงูุฅุถุงูุฉ (`insert`) ุฌูู ุงูู HashTable ุจุชุงุฎุฏ ููุช ุซุงุจุช $O(1)$. ูุฅูุช ุจุชูุดู ุงูู Cycle ูู ููุช ุณุฑูุน ุฌุฏุงู $O(n)$ ูููุง ูุงูุช ุงูู List ุทูููุฉ.

---

