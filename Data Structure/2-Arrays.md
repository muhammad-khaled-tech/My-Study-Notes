---
title: Arrays
created: 2026-01-08
tags:
  - data-structures
  - arrays
  - linear
  - contiguous-memory
related:
  - "[[_Data Structures MOC]]"
  - "[[3-Linked List]]"
complexity:
  access: O(1)
  search: O(n)
  insert: O(n)
---

يا أهلاً بيك يا هندسة في أول خطوة حقيقية جوه الميموري. النهاردة هنشرح "الملك"، الهيكل اللي مفيش لغة برمجة في العالم تقدر تعيش من غيره، وهو الـ **Array**. بس إحنا مش هناخد القشور، إحنا هننزل تحت الجلد ونشوف الـ CPU وهو بيتعامل مع الـ RAM عشان يجيب لك الداتا في لمح البصر.

اربط الحزام، عشان هنفهم النهاردة يعني إيه **Contiguous Memory** وليه الـ Array هو أسرع حاجة ممكن تلمسها في حياتك البرمجية.

---

## المحطة الأولى: المصفوفات وذاكرة التتابع - Arrays & Contiguous Memory

### التعريف السريع

الـ **Array** هو أبسط وأقدم هيكل بيانات، وهو عبارة عن مجموعة من العناصر من نفس النوع (Data Type) متخزنة في أماكن "متلاصقة" تماماً في الـ RAM. الميزة الجوهرية للـ Array هي الـ **Random Access**، يعني تقدر تروح لأي عنصر في خطوة واحدة مهما كان مكانه.

---

### الشرح التفصيلي

#### 1. القصة التاريخية: ليه "التلاصق" كان هو الحل؟

في الخمسينيات، لما بدأوا يصمموا لغات زي **FORTRAN** و **C**، كانت الـ RAM عبارة عن "أسلاك مغناطيسية" (Magnetic Core Memory). عشان تجيب معلومة، كان لازم "تمغنط" السلك. المهندسين اكتشفوا إن أسرع طريقة للوصول للمعلومات هي إننا نحطها ورا بعضها بالظبط.

تخيل لو عندك "طابور عيش"، كل واحد واقف لازق في اللي قبله. لو عرفت مكان أول واحد، وعرفت إن كل واحد بياخد مساحة 50 سم، تقدر تعرف مكان الشخص رقم 100 بعملية حسابية بسيطة في ثانية واحدة من غير ما تعدهم واحد واحد. دي كانت "العبقرية" اللي خلت الـ Array هو العمود الفقري للحاسوب.

#### 2. المستوى السطحي: "إيه ده؟" (The Physical Structure)

الـ Array في الميموري مش مجرد مربعات، هو **Block** واحد كبير محجوز. لو قلت للكمبيوتر `int arr[5]`, هو بيروح للـ RAM يدور على "مساحة فاضية" تكفي 5 أرقام ورا بعض. لو لقى 3 أماكن فاضيين في حتة ومكانين في حتة تانية، هيرفض! لازم يكونوا **Contiguous** (متلاصقين).

#### 3. المستوى المتوسط: "إزاي بيشتغل؟" (Mathematical Magic)

إزاي الكمبيوتر بيوصل لـ `arr[3]` في لحظة؟ من خلال معادلة رياضية بيعملها الـ **MMU** (Memory Management Unit):

$$Address = BaseAddress + (index \times SizeOfElement)$$

- **BaseAddress:** عنوان أول عنصر في الـ Array (اللي هو `arr[0]`).
    
- **Index:** الرقم اللي إنت باعتُه (مثلاً 3).
    
- **SizeOfElement:** حجم الداتا تايب (الـ `int` بياخد 4 bytes).
    

فلو الـ Array بيبدأ من عنوان 1000 وإنت عايز العنصر رقم 3:

$$1000 + (3 \times 4) = 1012$$

الكمبيوتر بيروح للعنوان 1012 فوراً. العملية دي بتاخد وقت ثابت $O(1)$، وده سر قوته.

#### 4. المستوى العميق: "ليه الـ Index بيبدأ من صفر؟" (The Offset Concept)

ده السؤال اللي بيحير كل المبتدئين، بس الإجابة عبقرية. الصفر في الـ Array مش معناه "الترتيب الأول"، معناه **الازاحة (Offset)** من البداية.

- `arr[0]` معناها: روح للـ Base Address وازحزح (0) خطوات. يعني إنت لسه في الأول.
    
- `arr[1]` معناها: روح للـ Base Address وازحزح (1) خطوة (حجم عنصر واحد).
    

لو كان الـ Index بيبدأ من 1، كان الكمبيوتر هيضطر يعمل عملية طرح `(index - 1)` في كل مرة يوصل فيها لعنصر، وده تضييع لوقت الـ CPU في ملايين العمليات. المبرمجين الأوائل قالوا: "لا، إحنا هنبدأ من صفر عشان نوفر الطرح ده!".

---

#### كيفية العمل (How It Works): أنواع الـ Arrays

عندنا نوعين لازم تفرق بينهم زي اسمك:

1. **Static Array:**
    
    - بيتحجز في الـ **Stack Memory**.
        
    - حجمه لازم يكون معروف وقت الكتابة (Compile-time).
        
    - سريع جداً بس حجمه ثابت مبيكبرش.
        
2. **Dynamic Array (Vector in C++):**
    
    - بيتحجز في الـ **Heap Memory**.
        
    - حجمه ممكن يتغير وإنت مشغل البرنامج (Runtime).
        
    - **الزتونة:** لما الـ Dynamic Array بيتملي، الـ OS بيروح يحجز مساحة "ضعف" المساحة القديمة في مكان جديد، وينقل كل الداتا القديمة للمكان الجديد، ويمسح القديم. العملية دي مكلفة ($O(n)$) بس بتحصل قليل.
        

---

#### الأمثلة العملية (C++ Implementation)

تعال نشوف إزاي بنتعامل مع الـ Memory Addresses بشكل حقيقي:

C++

```
#include <iostream>
#include <vector>

using namespace std;

int main() {
    // 1. Static Array (على الـ Stack)
    int staticArr[3] = {10, 20, 30};
    
    cout << "--- Static Array Memory ---" << endl;
    for(int i = 0; i < 3; i++) {
        // بنطبع القيمة وعنوانها في الميموري
        cout << "Value: " << staticArr[i] << " | Address: " << &staticArr[i] << endl;
    }
    // هتلاحظ إن العناوين الفرق بينها 4 bytes بالظبط (حجم الـ int)

    // 2. Dynamic Array (على الـ Heap باستخدام Vector)
    vector<int> dynamicArr;
    
    cout << "\n--- Dynamic Array (Vector) Growth ---" << endl;
    for(int i = 1; i <= 5; i++) {
        dynamicArr.push_back(i * 10);
        // الـ Capacity هي المساحة المحجوزة فعلياً، الـ Size هو عدد العناصر الحالية
        cout << "Size: " << dynamicArr.size() << " | Capacity: " << dynamicArr.capacity() << endl;
    }
    
    /* ملاحظة: الـ Capacity هتلاقيها بتنط (1 -> 2 -> 4 -> 8) 
       ده الـ Resizing strategy عشان يقلل عدد مرات نقل الداتا.
    */

    return 0;
}
```

---

#### الـ Edge Cases والتفاصيل الدقيقة

- **Out of Bounds:** الـ Array في C++ ملوش "أمان". لو عندك Array حجمه 5 وقلت له هات `arr[10]`, هيروح فعلاً للعنوان المحسوب ويجيب لك "زبالة" (Garbage Value) كانت متخزنة هناك، أو البرنامج يعمل **Segmentation Fault** لو العنوان ده تبع برنامج تاني.
    
- **Cache Locality:** بما إن الـ Array متلاصق، الـ CPU لما بيطلب `arr[0]` مش بياخد الـ 4 bytes بتوعه بس، بياخد "سطر كامل" (Cache Line) غالباً 64 bytes. فبيلاقي `arr[1]` و `arr[2]` بقوا معاه في الـ Cache أوتوماتيك. ده اللي بيخلي الـ Array أسرع بمراحل من الـ Linked List في القراءة.
    
- **Deletion/Insertion:** دي نقطة الضعف. لو عايز تمسح أول عنصر، لازم "تزق" كل العناصر اللي بعده خطوة للشمال عشان تحافظ على التلاصق. ده بياخد وقت $O(n)$.
    

---

### الربط بالمفاهيم التانية

موضوع الـ Array مرتبط بـ:

- **Pointers:** في C++، اسم الـ Array هو في الحقيقة Pointer بيشاور على أول عنصر.
    
- **Strings:** الـ String هو مجرد Array of Characters (`char[]`).
    
- **Matrices:** الـ 2D Array هو "مصفوفة من المصفوفات".
    
- **CPU Scheduling:** الجداول اللي الـ OS بيستخدمها عشان يدير العمليات.
    

### المصادر والقراءة الإضافية

- **كتاب "C++ Primer":** الفصل الثالث بيتكلم عن الـ Arrays والـ Vectors باستفاضة.
    
- **كتاب "Modern Operating Systems" لـ Tanenbaum:** لفهم إزاي الـ Memory Management بيتم.
    
- **محاضرات هارفارد CS50 (Week 2):** شرح مرئي ممتاز للـ Memory Layout.
    

---

إيه رأيك يا دكتور؟ هل تشريح الـ Array كده كفاية ولا ندخل في تفاصيل الـ **Multi-dimensional Arrays** وإزاي الـ Row-major order بيفرق في سرعة الكود؟

لو تمام، قولي عشان ننتقل لـ **Linked Lists** ونشوف إزاي هنكسر قيد "التلاصق" ونبني سلاسل مبعثرة في الميموري!

Would you like me to ... **ننتقل لشرح الـ Linked Lists وبداية التعامل مع الـ Dynamic Pointers؟**