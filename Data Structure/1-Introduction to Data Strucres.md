---
title: Introduction to Data Structures
created: 2026-01-08
tags:
  - data-structures
  - fundamentals
  - introduction
related:
  - "[[_Data Structures MOC]]"
  - "[[2-Arrays]]"
---


## محطة الصفر: فلسفة وجود هياكل البيانات

### التعريف السريع

هياكل البيانات (Data Structures) هي العلم اللي بيدرس إزاي ننظم ونخزن البيانات في ذاكرة الكمبيوتر بطريقة تسمح لنا بالوصول ليها وتعديلها بأعلى "كفاءة" ممكنة. هي الجسر اللي بيربط بين "البيانات الخام" وبين "الحلول البرمجية الذكية".

---

### الشرح التفصيلي: ليه الوجع الدماغ ده؟

بص يا بطل، إحنا ليه مش بنرمي كل الداتا في مصفوفة (Array) وخلاص؟ ليه قرفنا نفسنا بـ Linked Lists وشجر (Trees) وجرافات (Graphs)؟ الإجابة بتتلخص في كلمتين: **الموارد المحدودة (Limited Resources)**.

#### 1. القصة التاريخية: عصر الندرة (The Era of Scarcity)

في الخمسينيات والستينيات، كان المهندسين بيتعاملوا مع ذاكرة (Memory) حجمها بالكيلو بايت. إنت متخيل؟ يعني الميموري بتاعة الكمبيوتر كله أصغر من صورة سيلفي إنت واخدها بموبايلك دلوقتي. في الوقت ده، مكانش فيه رفاهية تضييع بايت واحد.

علماء زي **Tony Hoare** و **Donald Knuth** اكتشفوا إن الطريقة اللي بنرتب بيها الداتا في الميموري بتأثر بشكل مباشر على سرعة المعالج (CPU). لو الداتا مبعثرة، الـ CPU هيقضي وقته كله "يدور" بدل ما "يعالج". ومن هنا بدأوا يصمموا "هياكل" تخلي الداتا منظمة بطريقة تخدم الغرض منها.

#### 2. المستوى السطحي: "إيه ده؟" (The Physical Meaning)

تخيل لو دخلت مخزن عملاق فيه مليون كرتونة، ومطلوب منك تطلع كرتونة معينة فيها "شاشات". لو الكراتين مرصوصة فوق بعضها بشكل عشوائي، هتقعد أيام تدور. لكن لو الكراتين دي متوزعة في "أرفف" وكل رف ليه "عنوان" (Index) ومتقسمة حسب "النوع" (Classification)، هتطلعها في دقيقتين. الـ Data Structure هي "الأرفف" دي.

#### 3. المستوى المتوسط: "إزاي بتشتغل؟" (Efficiency: Time & Space)

أي هيكل بيانات بنقيمه بناءً على حاجتين، وهما دول "المقدسات" بتوعنا:

- **الوقت (Time Complexity):** العملية دي (بحث، إضافة، مسح) هتاخد كام خطوة من الـ CPU؟
    
- **المساحة (Space Complexity):** الهيكل ده هيشغل كام بايت من الـ RAM؟
    

اللعبة كلها هي **التوازن (Trade-offs)**. مفيش هيكل بيانات "مثالي" في كل حاجة. لو عايز سرعة بحث خارقة، هتضحي بمساحة ميموري (زي الـ Hashing). لو عايز توفر ميموري جداً، هتضحي بشوية سرعة (زي الـ Linked Lists). مهندس الـ ITI الشاطر هو اللي بيعرف يختار الهيكل اللي يناسب "المشكلة" اللي قدامه.

#### 4. المستوى العميق: "ليه اتصمم كده؟" (Memory & Hardware Connection)

هنا بقى الحتة اللي بنحبها. الـ RAM (Random Access Memory) من اسمها "وصول عشوائي"، يعني تقدر تروح لأي عنوان في لحظة. لكن الحقيقة إن الـ CPU فيه حاجة اسمها **Cache**.

- لو الداتا مرصوصة ورا بعضها (زي الـ Array)، الـ CPU بياخد "بلوك" كامل يحطه في الـ Cache، فالبحث بيبقى طلقة (Spatial Locality).
    
- لو الداتا مبعثرة (زي الـ Linked List)، الـ CPU كل شوية يضطر يروح للـ RAM البطيئة، وده بيعمل Cache Miss.
    
    إحنا صممنا هياكل البيانات عشان "نسايس" الهاردوير ونخليه يشتغل بأقصى طاقته.
    

---

#### كيفية العمل (How It Works): السيناريوهات الواقعية

عشان تفهم إحنا محتاجينها ليه، بص على الأمثلة دي من قلب تكنولوجيا اليومين دول:

1. **في الـ Operating System:** الـ OS بيستخدم **Stacks** عشان يدير الـ Function Calls والـ Recursion. من غير الـ Stack، الكمبيوتر مش هيعرف يرجع للسطر اللي كان واقف عنده بعد ما يخلص الـ function.
    
2. **في الـ Networking:** الـ Routers بتستخدم **Queues** عشان تخزن الـ Packets اللي جاية بسرعة أعلى من قدرة المعالجة. لو مفيش Queue، الـ Packets دي هتضيع (Drop).
    
3. **في الـ Google Maps:** الخريطة اللي إنت شايفها دي عبارة عن **Graph** عملاق. كل شارع هو وصلة (Edge) وكل تقاطع هو نقطة (Node). البحث عن أقصر طريق هو خوارزمية بتشتغل على الـ Graph ده.
    

---

#### الأمثلة العملية: الـ Array البسيط كبداية

بص للكود ده، بيوريك إزاي "تنظيم" الداتا بيفرق في فهمنا ليها:



```C++
#include <iostream>
#include <string>

using namespace std;

// تخيل لو عندنا بيانات موظف، ممكن نخزنها مبعثرة
// وممكن ننظمها في هيكل (Structure)
struct Employee {
    int id;
    string name;
    double salary;
};

int main() {
    // الطريقة البدائية (بدون هيكل بيانات منظم)
    int id1 = 101;
    string name1 = "Ahmed";
    double salary1 = 5000.0;

    // الطريقة المنظمة (هيكل بيانات بسيط: Array of Structs)
    // هنا الداتا بقت "كتلة واحدة" في الميموري، الوصول ليها أسهل بكتير
    Employee employees[2];
    
    employees[0] = {101, "Ahmed", 5000.0};
    employees[1] = {102, "Mona", 6000.0};

    for(int i = 0; i < 2; i++) {
        cout << "ID: " << employees[i].id << " | Name: " << employees[i].name << endl;
    }

    return 0;
}
```

#### الـ Edge Cases والتفاصيل الدقيقة

- **الـ Static vs Dynamic:** لو حجزت مصفوفة (Array) كبيرة زيادة عن اللزوم، إنت بتعمل **Memory Waste**. لو حجزتها صغيرة، البرنامج هيضرب (Buffer Overflow). دي أول مشكلة واجهت المبرمجين وخلتهم يخترعوا الـ **Dynamic Data Structures**.
    
- **الـ Pointer Overhead:** في الـ Linked Lists، إنت بتخزن الداتا ومعاها "عنوان اللي بعدها" (Pointer). الـ Pointer ده بياخد مساحة (4 أو 8 bytes). لو الداتا اللي بتخزنها أصلاً صغيرة (مثلاً char بياخد 1 byte)، فأنت كده بتستهلك ميموري للـ Pointers أكتر من الداتا نفسها! ده بنسميه **Memory Overhead**.
    

---

### الربط بالمفاهيم التانية

الموضوع ده هو "أم العلوم البرمجية" ومرتبط بـ:

- **Computer Architecture:** إزاي الـ CPU والـ RAM بيكلموا بعض.
    
- **Operating Systems:** إدارة الـ Process والـ Threads.
    
- **Database Management Systems:** إزاي بنخزن ملايين السجلات ونبحث فيها بلحظة.
    

### المصادر والقراءة الإضافية

- **كتاب "Introduction to Algorithms" (CLRS):** الفصل العاشر بيتكلم عن الهياكل الأساسية.
    
- **كتاب "The Art of Computer Programming" لـ Donald Knuth:** ده المرجع التاريخي اللي قعد قواعد العلم ده.
    
- **كورس CS50 (Week 5):** بيشرح الـ Memory والـ Data Structures بشكل عبقري.
    

