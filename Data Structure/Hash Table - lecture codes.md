

# الجزء الأول: الفلسفة العميقة (لماذا الـ Hashing؟)

### 1. معضلة البحث (The Search Dilemma)

تخيل لو عندك مخزن فيه **مليون** كرتونة، وكل كرتونة ليها "رقم تسلسلي" (Serial Number) مكون من 10 أرقام.

- **لو استخدمت Array أو Linked List:** عشان تلاقي كرتونة معينة، هتضطر تمشي عليهم واحدة واحدة. ده بياخد وقت $O(n)$.
    
- **لو استخدمت BST:** هتاخد وقت $O(\log n)$. يعني لو عندك مليون عنصر، هتعمل حوالي 20 مقارنة.
    

**السؤال الصعب:** هل نقدر نلاقي الكرتونة في **خطوة واحدة بس** ($O(1)$) مهما كان عدد الكراتين؟ الإجابة هي: **نعم، بالحساب لا بالتدوير.**

### 2. فكرة الـ "Direct Address Table" (الحل البدائي)

الحل الأسهل هو إننا نحجز مصفوفة (Array) حجمها يغطي كل الأرقام التسلسلية الممكنة. لو الأرقام من 0 لـ 99، هحجز Array فيها 100 خانة. الكرتونة رقم 50 هحطها في الـ Index رقم 50.

- **المشكلة:** لو الأرقام التسلسلية مكونة من 10 أرقام (مليار احتمال)، هتحتاج Array حجمها مليار! ده "إسراف" مرعب في الميموري لأنك غالباً معندكش غير 1000 كرتونة بس.
    

### 3. الحل العبقري: الـ Hashing (عملية التكميش)

الـ Hashing هو عملية "ضغط" أو "تكميش" للمجال الواسع (مليار رقم) لمجال صغير (مثلاً 100 خانة) باستخدام معادلة رياضية.

- **الـ Hash Function:** هي "المفرمة". تديها رقم ضخم (Key)، تطلعلنا رقم صغير (Index) يقع جوه حدود المصفوفة بتاعتنا.
    

---

# الجزء الثاني: الرياضيات وراء الـ Hash Function

المعادلة الأشهر والأبسط اللي استخدمها بشمهندس مينا هي **"باقي القسمة" (Modulo Operator)**:

$$index = key \pmod{size}$$

### ليه بنستخدم باقي القسمة؟

لأن ناتج باقي القسمة على أي رقم (مثلاً 10) مستحيل يطلع أكبر من 9 أو أصغر من 0. ده بيضمن إننا دايماً "جوه الملعب" (Array Bounds).

مثال عملي (عصر دماغ):

لو عندنا مصفوفة حجمها (Size) = 10.

1. الرقم **15**: $15 \pmod{10} = 5$. (سكنه في الخانة 5).
    
2. الرقم **7**: $7 \pmod{10} = 7$. (سكنه في الخانة 7).
    
3. الرقم **25**: $25 \pmod{10} = 5$. (**هنا بدأت المشكلة!**).
    

---

# الجزء الثالث: كارثة الـ Collision (التصادم)

بما إننا "بنكمش" أرقام كتير في مساحة صغيرة، طبيعي جداً إن رقمين مختلفين يروحوا لنفس المكان. ده بنسميه **Collision**.

### إزاي بنحل الخناقة دي؟ (Collision Resolution)

فيه مدرستين كبار، وبشمهندس مينا اختار المدرسة الأفضل في المرونة وهي **Separate Chaining**:

- **الفكرة:** بدل ما الخانة في المصفوفة تشيل "رقم"، هنخليها تشيل "عنوان" (Pointer). العنوان ده بيشاور على Linked List.
    
- **اللي بيحصل:** لو رقم 5 راح للخانة 5، هعمل نود وأحطها هناك. طب لو رقم 15 جه لنفس الخانة؟ هربطه "ورا" رقم 5 في نفس السلسلة.
    

---

# الجزء الرابع: كود "فرفوش" (تدريب بسيط قبل الجد)

تعال نطبق فكرة الـ Hash Function بس بشكل بسيط جداً بعيد عن التعقيدات، عشان نتأكد إن المفهوم وصل.

C++

```
#include <iostream>

int main() {
    int tableSize = 10;
    int myData[] = {15, 22, 35, 42};

    for(int i = 0; i < 4; i++) {
        // حساب الـ Index
        int index = myData[i] % tableSize; 
        
        std::cout << "Value: " << myData[i] 
                  << " goes to Index: " << index << std::endl;
    }
    return 0;
}
```

تمرين ليك قبل ما ننقل للي بعده:

في الكود البسيط ده، مين الأرقام اللي هيحصل بينهم Collision لو الـ tableSize بقى 5 بدل 10؟

---

يا محمد، أنا كدة "فرشت" لك الموضوع بعمق أكبر: (المشكلة -> الحل البدائي -> الحل العبقري -> المشكلة الجديدة "التصادم" -> حل التصادم).

**هل الجزء النظري ده والرياضيات بتاعته (باقي القسمة) بقوا واضحين تماماً في خيالك؟** لو تمام، قولي عشان أديك كود "Dictionary" صغير ونعمله Trace سوا، وبعدها ندخل في تفاصيل كود مينا "التقيلة".

Would you like me to ... **أديك مثال عملي لمشكلة حقيقية (زي أرقام التليفونات) ونشوف إزاي الـ Hashing بيحلها برمجياً؟**