

# الجزء الأول: الفلسفة العميقة (لماذا الـ Hashing؟)

### 1. معضلة البحث (The Search Dilemma)

تخيل لو عندك مخزن فيه **مليون** كرتونة، وكل كرتونة ليها "رقم تسلسلي" (Serial Number) مكون من 10 أرقام.

- **لو استخدمت Array أو Linked List:** عشان تلاقي كرتونة معينة، هتضطر تمشي عليهم واحدة واحدة. ده بياخد وقت $O(n)$.
    
- **لو استخدمت BST:** هتاخد وقت $O(\log n)$. يعني لو عندك مليون عنصر، هتعمل حوالي 20 مقارنة.
    

**السؤال الصعب:** هل نقدر نلاقي الكرتونة في **خطوة واحدة بس** ($O(1)$) مهما كان عدد الكراتين؟ الإجابة هي: **نعم، بالحساب لا بالتدوير.**

### 2. فكرة الـ "Direct Address Table" (الحل البدائي)

الحل الأسهل هو إننا نحجز مصفوفة (Array) حجمها يغطي كل الأرقام التسلسلية الممكنة. لو الأرقام من 0 لـ 99، هحجز Array فيها 100 خانة. الكرتونة رقم 50 هحطها في الـ Index رقم 50.

- **المشكلة:** لو الأرقام التسلسلية مكونة من 10 أرقام (مليار احتمال)، هتحتاج Array حجمها مليار! ده "إسراف" مرعب في الميموري لأنك غالباً معندكش غير 1000 كرتونة بس.
    

### 3. الحل العبقري: الـ Hashing (عملية التكميش)

الـ Hashing هو عملية "ضغط" أو "تكميش" للمجال الواسع (مليار رقم) لمجال صغير (مثلاً 100 خانة) باستخدام معادلة رياضية.

- **الـ Hash Function:** هي "المفرمة". تديها رقم ضخم (Key)، تطلعلنا رقم صغير (Index) يقع جوه حدود المصفوفة بتاعتنا.
    

---

# الجزء الثاني: الرياضيات وراء الـ Hash Function

المعادلة الأشهر والأبسط اللي استخدمها بشمهندس مينا هي **"باقي القسمة" (Modulo Operator)**:

$$index = key \pmod{size}$$

### ليه بنستخدم باقي القسمة؟

لأن ناتج باقي القسمة على أي رقم (مثلاً 10) مستحيل يطلع أكبر من 9 أو أصغر من 0. ده بيضمن إننا دايماً "جوه الملعب" (Array Bounds).

مثال عملي (عصر دماغ):

لو عندنا مصفوفة حجمها (Size) = 10.

1. الرقم **15**:-------------------->  $15 \pmod{10} = 5$. (سكنه في الخانة 5).
    
2. الرقم **7**:--------------------> $7 \pmod{10} = 7$. (سكنه في الخانة 7).
    
3. الرقم **25**:--------------------> $25 \pmod{10} = 5$. (**هنا بدأت المشكلة!**).
    

---

# الجزء الثالث: كارثة الـ Collision (التصادم)

بما إننا "بنكمش" أرقام كتير في مساحة صغيرة، طبيعي جداً إن رقمين مختلفين يروحوا لنفس المكان. ده بنسميه **Collision**.

### إزاي بنحل الخناقة دي؟ (Collision Resolution)

فيه مدرستين كبار، وبشمهندس مينا اختار المدرسة الأفضل في المرونة وهي **Separate Chaining**:

- **الفكرة:** بدل ما الخانة في المصفوفة تشيل "رقم"، هنخليها تشيل "عنوان" (Pointer). العنوان ده بيشاور على Linked List.
    
- **اللي بيحصل:** لو رقم 5 راح للخانة 5، هعمل نود وأحطها هناك. طب لو رقم 15 جه لنفس الخانة؟ هربطه "ورا" رقم 5 في نفس السلسلة.
    

---

# الجزء الرابع: كود "فرفوش" (تدريب بسيط قبل الجد)

تعال نطبق فكرة الـ Hash Function بس بشكل بسيط جداً بعيد عن التعقيدات، عشان نتأكد إن المفهوم وصل.



```C++
#include <iostream>

int main() {
    int tableSize = 10;
    int myData[] = {15, 22, 35, 42};

    for(int i = 0; i < 4; i++) {
        // حساب الـ Index
        int index = myData[i] % tableSize; 
        
        std::cout << "Value: " << myData[i] 
                  << " goes to Index: " << index << std::endl;
    }
    return 0;
}
```

```output
Value: 15 goes to Index: 5
Value: 22 goes to Index: 2
Value: 35 goes to Index: 5
Value: 42 goes to Index: 2

```

---

نور عليك يا محمد! إجابتك دقيقة 100%. إنت كدة مسكت طرف الخيط صح في الـ Hashing وهو **"توقع أماكن التصادم"**.

بما إنك حسبتها صح:

1. $15 \pmod 5 = 0$ و $35 \pmod 5 = 0$ (تصادم في الخانة 0).
    
2. $22 \pmod 5 = 2$ و $42 \pmod 5 = 2$ (تصادم في الخانة 2).
    

---

# الجزء الخامس: تخيل "المأساة" في الميموري

تخيل لو إنت عامل مصفوفة (Array) عادية من 5 خانات، وجيت تخزن الأرقام دي:

- هتحط الـ 15 في الخانة 0.
    
- لما تيجي تحط الـ 35، هتلاقي الخانة 0 محجوزة.. هتعمل إيه؟ لو "دهست" الـ 15 وحطيت الـ 35 مكانها، يبقى ضيعت بياناتك (Data Loss).
    

---

# الجزء السادس: كود "فرفوش" (إزاي بنحل الخناقة دي يدوياً؟)

قبل ما ندخل في "تقفل" كود بشمهندس مينا، تعال نشوف أبسط طريقة برمجية لحل المشكلة دي وهي **الـ Chaining** (إني أحول كل خانة لـ Array تانية صغيرة أو Linked List).

تعال نعمل كود "يدوي" جداً بيستخدم `vector` جوه `array` عشان نوضح الفكرة من غير تعقيد الـ Pointers:



```C++
#include <iostream>
#include <vector>

int main() {
    int size = 5;
    // مصفوفة من الـ Vectors (كل خانة عبارة عن شنطة بتشيل أرقام كتير)
    std::vector<int> hashTable[5]; 

    int keys[] = {15, 22, 35, 42};

    for(int i = 0; i < 4; i++) {
        int index = keys[i] % size;
        // بنضيف الرقم في الشنطة بتاعته حتى لو فيه غيره
        hashTable[index].push_back(keys[i]); 
    }

    // تعال نتفرج على شكل الجدول
    for(int i = 0; i < size; i++) {
        std::cout << "Index " << i << ": ";
        for(int val : hashTable[i]) {
            std::cout << val << " -> ";
        }
        std::cout << "NULL" << std::endl;
    }

    return 0;
}
```
```output
Index 0: 15 -> 35 -> NULL
Index 1: NULL
Index 2: 22 -> 42 -> NULL
Index 3: NULL
Index 4: NULL

```
### إيه اللي حصل هنا؟

1. في الخانة (Index 0): الـ Vector شال الـ 15 والـ 35 مع بعض.
    
2. في الخانة (Index 2): الـ Vector شال الـ 22 والـ 42 مع بعض.
    
3. باقي الخانات فضلت فاضية.
    


---

# الجزء السابع: ليه بشمهندس مينا مستخدمش الـ Vector؟

بما إننا في كورس Data Structures، الهدف إننا نبني كل حاجة من الصفر (Low-level). الـ `std::vector` اللي استخدمته أنا فوق هو أداة جاهزة في C++، لكن بشمهندس مينا عاوز يعلمك إزاي تبني الـ "الشنطة" دي باستخدام الـ **Linked List** يدوياً:

- لأن الـ Linked List في الميموري أكفأ بكتير في الإضافة والحذف المستمر.
    
- عشان تتعلم إزاي تتحكم في الـ Pointers بنفسك وتعرف الـ `Node** table` دي بتعمل إيه بالظبط.
    

---

